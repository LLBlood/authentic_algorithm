# authentic_algorithm
来源于不同书籍的算法学习
## 1、算法图解
代码存放于路径：cn.liulin.algorithm.diagram
### 1.1 二分查找法 
代码路径： cn.liulin.algorithm.diagram.BinarySearchMethod

为什么需要二分查找法，在排序队列中，如果需要找到一个数，二分查找法可能是最有效的

比如1~100，查找63

第一次，50 小 （1+100） / 2

第二次，75 大 （50+100） / 2

第三次，62 小 （50+75） / 2

第四次，68 大 （62+75） / 2

第五次，65 大 （62+68） / 2

第六次，63 等 （62+65） / 2

所以只需要6次，而普通查询，则需要63次，随着数据量的不断增大，两者查询速度也会不断增大

二分查找法时间表示O(log n), 普通查询O(n)

<font color="red">注意：当角标位置对应的元素小于或者大于目标元素，角标位置本身的元素不再算入，则小于时，起始角标应该对应中间角标+1，则大于时，结束角标应该对应中间角标-1</font>

### 1.2 选择排序

代码路径： cn.liulin.algorithm.diagram.SelectSort

```java
151,2,343,53,65,75,23,12,14,6,67,87
找出上面最小的数2，与第一位151交换
2,151,343,53,65,75,23,12,14,6,67,87
再找出 151,343,53,65,75,23,12,14,6,67,87 最小的数6，与第一位151交换
2,6,343,53,65,75,23,12,14,151,67,87
依次进行，直到最后排序完毕
```

相当于每次查询当前临时数组中最小的一位数，放在最前面，最终排序完毕

所需时间n*(n-1)*(n-2).....1 最终O(n^2)