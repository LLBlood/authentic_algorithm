# authentic_algorithm
来源于不同书籍的算法学习
## 1、算法图解
代码存放于路径：cn.liulin.algorithm.diagram
### 1.1 二分查找法 
代码路径： cn.liulin.algorithm.diagram.BinarySearchMethod

为什么需要二分查找法，在排序队列中，如果需要找到一个数，二分查找法可能是最有效的

比如1~100，查找63

第一次，50 小 （1+100） / 2

第二次，75 大 （50+100） / 2

第三次，62 小 （50+75） / 2

第四次，68 大 （62+75） / 2

第五次，65 大 （62+68） / 2

第六次，63 等 （62+65） / 2

所以只需要6次，而普通查询，则需要63次，随着数据量的不断增大，两者查询速度也会不断增大

二分查找法时间表示O(log n), 普通查询O(n)

<font color="red">注意：当角标位置对应的元素小于或者大于目标元素，角标位置本身的元素不再算入，则小于时，起始角标应该对应中间角标+1，则大于时，结束角标应该对应中间角标-1</font>

### 1.2 选择排序

代码路径： cn.liulin.algorithm.diagram.SelectSort

```java
151,2,343,53,65,75,23,12,14,6,67,87
找出上面最小的数2，与第一位151交换
2,151,343,53,65,75,23,12,14,6,67,87
再找出 151,343,53,65,75,23,12,14,6,67,87 最小的数6，与第一位151交换
2,6,343,53,65,75,23,12,14,151,67,87
依次进行，直到最后排序完毕
```

相当于每次查询当前临时数组中最小的一位数，放在最前面，最终排序完毕

所需时间n*(n-1)*(n-2).....1 最终O(n^2)

### 1.3 递归

代码路径： cn.liulin.algorithm.diagram.Recursion

递归最主要就是要弄明白什么是基准条件，什么是递归条件，从而满足递归开始结束因素

### 1.4 快速排序

代码路径： cn.liulin.algorithm.diagram.QuickSort

快速排序，主要利用了分而治之的思路，选定基准值，分隔比他大的数组及比他小的数组，再到两个数组中，重新选定基准值

比如 151,2,343,53,65,75,23,12,14,6,67,87 ，想要做到基准值右边大，左边小

选定基准值baseX = a[0] = 151, low = 0, high = 11

此时a[0]就是一个坑等着右边小的填，a[11] < baseX ,所以此时a[0] = a[11] = 87, low++;

此时a[11]就是一个坑等着左边大的填，a[1] < baseX 循环low++ 直到 a[2] > baseX， 所以此时a[11] = a[2] = 343, high++

......

直到不满足low <= high之后

可以预见基准值右边大，左边小，然后分而治之

### 1.5 广度优先搜索

代码路径：cn.liulin.algorithm.diagram.BreadthFirstSearch

图片示例路径：cn/liulin/algorithm/diagram/BreadthFirstSearch.png

广度优先搜索；

​	1、可解决A点到B点是否有路径

​	2、可解决A点到B点最短路径

例如：从朋友圈找到iphone经销商

首先从自己的朋友开始找，找不到就从朋友的朋友找，直到找到为止

将自己的朋友加入队列（先进先出FIFO）,找不到就把朋友的朋友加入队列，当然要排除已加入队列的人

## 2、大话设计模式

代码存放于路径：cn.liulin.algorithm.dhdesign.zzl

### 2.1 职责链模式

每一个对象都可以处理请求，但是能够处理请求的范围不一样，当下级对象无法处理请求时，转到上级对象进行处理请求。

比如请假申请，部门主管->公司经理->公司董事长，每个级别能够处理的申请范围不一样

使多个对象都有机会处理请求，从而避免请求的发起者和接收者之间的耦合关系，将这个对象连成一条链，并沿着这条链处理请求，直到有一个对象能够处理它为止。

职责链模式相当于，一个请求当前对象无法处理，就会转到下个对象处理，直到获得处理结果为止。

[职责链模式](https://blog.csdn.net/qq_43479628/article/details/114838375)